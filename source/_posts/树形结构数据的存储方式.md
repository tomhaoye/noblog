---
title: 树形结构数据的存储方式
date: 2019-10-13 13:11:36
tags: design
categories: 总结
---

> 之前我们说到了面向对象语言层面树形结构数据的抽象，今天我们那来看看树形结构的数据一般是如何存储在数据库里面的。

### 前言

最近对树形结构的数据有比较浓厚的研究学习兴趣，具体的原因嘛，嘿嘿你猜。

上一篇文章里面提到了之前我们的树形结构数据的存储方式，就是大家都很常用的`pid`关联父级`id`，想必这种存储方式是大多数人一贯的选择方案，毕竟这种存储方式很符合人类正常的思考模式，而且自顶而下的查询也是递归查询，跟我们日常习惯相符合。

然而人类的常规思维总有一些限制，当参数变得复杂就会变得十分低效，所以符合人类的思考模式的方式尽管能够让人易于理解，但却不一定是好的方式。

### 存储方式

所以回归到主题，对于树形结构的数据有哪些存储方式呢？这些存储方式中有没有最优的呢？如果没有那么各种方式分别适合于什么样的场景呢？又各有什么限制呢？

下面内容是对 《SQL Antipatterns》 中提到的四种树形结构数据的存储方式的概括，我们带着以上的问题，尝试着去寻找答案。

#### Adjacency List

这种就是我们最常用的方式，这种存储方式在插入、修改和删除节点的时候会比较有优势，基本的表设计就是如下：

|id|pid|name|
|--|--|----|
|1|0|Level1|
|2|1|Level2|
|3|2|Level3|

一般可以使用`0`作为所有节点的虚拟根节点，`0`节点可以不存在数据库中，查第一层的数据只要将`pid=0`的条件带上就可以了。得到结果集后再遍历所有并使用结果的`id`作为之后查询条件的`pid`条件进行查询，如此重复下去直到每个查询得到的结果集都为空，那么就完成了完整的一棵树的查询。每个查询完成你可以将数据放到数组里面，或者像上一篇所说自己定义树结构，最后得出一个带层级关系的多维数组或者树。

以上是想要获取整棵树的一般查询方式，用到就是递归，有多少个节点就需要查询多少次，除了由上而下的查询之外，由下而上的反向查询也是需要递归查询直到`pid=0`为止才能获取到所有相关的父级节点。所以大家可以看到这种存储和查询方式在节点和层级十分多的时候可能会出现效率的问题。

一开始说到这种存储方式在增删改的时候有优势，可能大家以往没有意识到这点，因为所谓的优势也是需要通过对比才能体现出来的，那么下面我们先来看看其他几种存储方式吧。

#### Path Enumeration

大家先看一下这种设计的表结构：

|id|path|name|
|--|--|----|
|1|1|Level1|
|2|1/2|Level2|
|3|1/2/3|Level3|

这种方式就是将每个节点的完整路径存储下来，那么我们查询子所有的节点就需要如下SQL：

```SQL
select * from table where path like '1/%';
```

没错使用的就是模糊查询，由于没有使用左通配符，索引还是能用的，这种方式下查询所有的父节点也非常方便，因为完整的路径已经查出来了，那么利用分隔符获得所有父节点的`id`再使用`in`查询就成了。当然反向`like`也行：

```SQL
select * from table where '1/2/3' like path || '%';
```

当然这种方式局限性也非常的大，例如在你需要更改节点`2`的`path`为`2`，那么你还必须将节点`3`的`path`更新为`2/3`，关联的节点越多，需要更新的记录数就越多，删除节点同理；另外，由于`path`是存储每个节点的完整路径，所以一旦树的高度非常的高，那么`path`所存储的数据量就会很大，占用十分多的存储空间。

最后书里面还提到了一点就是脏数据的问题，因为这种存储方式在修改的插入的时候需要更改非常多的记录，另外还需要对`path`进行解析，比较容易出现格式异常、更改记录失败或者使用大事务，所以为了避免出现脏数据，就需要程序做到比较完善的校验规则。

#### Nested Sets


这种解决方案存储与属于其后代集的每个节点（而不是该节点的直接父级）有关的信息。 可以通过用两个数字对树中的每个节点进行编码来表示此信息，我们可以将其称为`nsleft`和`nsright`。

这种存储方式的表结构如下：

|id|nsleft|nsright|name|
|--|----|------|-------|
|1|1|14|node1|
|2|2|7|node2|
|3|3|4|node3|
|4|5|6|node4|
|5|8|13|node5|
|6|9|10|node6|
|7|11|12|node7|

每个节点通过以下方式获得`nsleft`和`nsright`：`nsleft`小于所有节点的子代数，而`nsright`大于所有节点的子代数。关于如何分配这些值，一种比较简单方法是沿着树的深度优先遍历，当下降时，递增的分配`nsleft`，而当上升时，递增的分配`nsright`。

为每个节点分配了这些编号后，就可以使用它们来查找任何给定节点的祖先和后代。 例如，我们可以通过搜索编号在当前节点的`nsleft`和`nsright`之间的节点来检索`id`为`2`的节点及其后代。
```SQL
SELECT t1.* FROM table t1 JOIN table t2 ON t2.nsleft BETWEEN t1.nsleft AND t1.nsright WHERE t1.id = 2;
```

可以通过搜索编号跨越当前节点编号的节点来检索`id`为`6`的节点及其祖先。
```SQL
SELECT t1.* FROM table t1 JOIN table t2 ON t1.nsleft BETWEEN t2.nsleft AND t2.nsright WHERE t1.id = 6;
```

这种设计的主要优势在于，当删除一个非叶子节点时，其后代会自动被视为已删除节点的父节点的直接子节点。 尽管插图中显示的每个节点的左右数字具有形成连续序列的值，并且与相邻的兄弟节点和父节点相比，差异始终为`1`，但是对于该设计来说，保留层次结构并不是必需的。 因此，当删除节点导致数值不连续时，也并不会中断树结构。

这种存储模型最适合用于快速地对子树执行查询，而不利于对单个节点进行操作。 因为插入和移动节点很复杂，且需要重新编号`nsleft`和`nsright`。 如果频繁对树插入节点的话，则这种设计是十分不理想的。

#### Closure Table

这四种方法里面唯一一个需要两张表的存储方式，就是这个`Closure Table`了，老规矩我们先上表设计为敬。

|id|name|
|--|----|
|1|Level1|
|2|Level2|
|3|Level3|

|fid|sid|
|--|----|
|1|1|
|1|2|
|1|3|
|2|2|
|2|3|
|3|3|

这种存储方式实际上就是使用另外一个表去表示关联关系。`fid`是当前父节点的`id`，`sid`则是子节点的`id`，换言之每个节点都会关联上它所有的子节点。

所以查询子节点和父节点的方式也是一目了然：

```SQL
# 查询相关子节点
select * from table_level where id in (select sid in table_relation where fid = 1);
# 查询相关父节点
select * from table_level where id in (select fid in table_relation where sid = 3);
```

插入新的节点呢，节点信息表就直接新增一条记录并获取到`id`（例如`id`为4），然后作为`level3`的子节点：

```SQL
INSERT INTO table_path (fid, sid) SELECT t.fid, 4 FROM table_path AS t WHERE t.sid = 3 union all select 4,4;
```

删除节点以及删除子树也非常的简单：

```SQL
# 删除节点
delete from table_path where sid = 3;
# 删除子树
delete from table_path where sid in (select sid from table_path where fid = 2);
```


`Closure Table` 是最通用的设计，也是唯一允许一个节点属于多个树的设计。 它需要一个附加表来存储关系，此设计在对深层次进行编码时还使用了大量行，因此增加了空间消耗。

### 总结
