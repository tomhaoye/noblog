---
title: 你真的会写冒泡排序吗？
date: 2019-03-14 23:31:13
tags: Sorting algorithms
categories: 算法
---

>大多数人接触到的第一种排序算法恐怕非冒泡排序莫属，它的排序思想十分的简单直观，相信大家都能用很简短的代码来实现冒泡排序，但是往往越简单的东西，能玩得花样就越多，今天我就来抛砖引玉，希望大家能给出会72变的冒泡排序。

废话就不多说了，简单的冒泡排序代码敬上：

```php
<?php
$arr = [7, 6, 8, 9, 0, 1, 5, 4, 3, 2];
$n = count($arr);
for ($j = 1; $j < $n; $j++) {
    for ($i = 0; $i < $n - $j; $i++) {
        if ($arr[$i + 1] < $arr[$i]) {
            $arr[$i] += $arr[$i + 1];
            $arr[$i + 1] = $arr[$i] - $arr[$i + 1];
            $arr[$i] = $arr[$i] - $arr[$i + 1];
        }
    }
}
print_r($arr);
```

OK，代码就这么简单，高高兴兴的写完了，这时候面试官问：代码还有优化空间吗？

<center>
{% asset_img 1.jpg %}
</center>

难道面试官看到了代码有bug？还是说字太丑了？如果你这时候说：那必须的，我给你换个静态编译的语言写一遍！

<center>
{% asset_img 2.jpg %}
</center>

那恐怕这道题目就到此为止了。面试官真正的目的是什么，其实大家都心知肚明，只是在面试过程中由于紧张等情绪影响，会错失一些加分的机会，所以我们平时就要学会多思考，再简单的知识点我们都可以往深挖掘，培养好习惯，那下次遇到一些开放式题目的时候，就算想不出，心里也能坦荡荡。:joy:

扯了那么多，赶紧回到正题。我们可以看到上面的代码，实在太简单了，简单到你只要你的待排序数组元素数量一样，不管你的待排序数组内容如何，甚至已经是完全排好序的，它的遍历的次数也是固定的。这就十分的浪费资源了，所以我们得想办法让它对已经排好序的数组停止遍历，放开那个数组，冲我来！

没错，我们要做的就是半路叫停它，教育它，让它迷途知返。我们都很清楚冒泡排序它的特点，那就是元素交换，既然我们都抓住了它的把柄了，教育便是水到渠成的事情了。

```php
<?php
$arr = [7, 6, 8, 9, 0, 1, 5, 4, 3, 2];
$n = count($arr);
for ($j = 1; $j < $n; $j++) {
    $changeFlag = false;
    for ($i = 0; $i < $n - $j; $i++) {
        if ($arr[$i + 1] < $arr[$i]) {
            $changeFlag = true;
            $arr[$i] += $arr[$i + 1];
            $arr[$i + 1] = $arr[$i] - $arr[$i + 1];
            $arr[$i] = $arr[$i] - $arr[$i + 1];
        }
    }
    if(!$changeFlag) {
        break;
    }
}
print_r($arr);
```

其实就是这么简单，给它立个`flag`，要是`flag`达成了，那好说，你可以继续；要是没达成，那就乖乖给俺放弃，不要执迷不悟了，勉强是没有幸福的。

优化了代码之后，你感觉自己像成功的教育了一个孩子一样开心无比，刚好面试官又在你对面，你就可以跟面试官倾诉，你是如何含辛茹苦的将这个孩子养育成人的。然而面试官却说：我觉得还有优化空间欸，你觉得呢？

你就想，那当然啊，孩子能考上大学，谁也不想高中就辍学啊。可是家庭条件不允许啊，面试官你要体谅我啊。

<center>
{% asset_img 4.png %}
</center>

心里虽然这么想，但是嘴巴却很巴结：嗯！我也是这么觉得的。面试官：那……。你：那容我先解决一下内急！

接下来就是东拼西凑的时候了，必须要借够钱让孩子上大学！当然，网贷这种东西，最好别碰，出了事自己都搭进去了。所谓的东拼西凑，当然是指努力寻找你脑海中的记忆碎片，说不定还能找到新大陆。但是在找到新大陆前，你最好还是先想想有没有老办法可以解决这个问题。你一脸懵逼：老办法？

没错啊，不是刚刚才写完了吗？你这么快就忘了你怎么含辛茹苦的将它养育成人吗？

此时你的脑海中：

<center>
{% asset_img 5.png %}
</center>

你的记忆是鱼的记忆吗？突然你恍然大悟，说道：你的意思是面试官可能跟鱼一样只有7秒记忆，就算我把刚刚的代码再写一遍，面试官也看不出来？

<center>
{% asset_img 6.gif %}
</center>

醒醒，你再不出去面试官就要来厕所找你了。你心里着急道：可是还没想还有啥办法啊！

老办法是不能再写一遍，但是可以按老思路再将老办法优化一下啊。你回想一下刚刚的老办法是等到某次遍历之后的发现完全没有`flag`达成才退出循环，但是过程中你不知道它到底在哪些地方达成了`flag`。一旦你能够得知它在哪些地方达成了`flag`，那么就可以让它避免弯路，直接踏上通往成功的捷径了。

你回到了面试间，心里嘀咕着些什么，抓起了笔开始写代码，这次你特意将字写得特别大，不知道是为了掩饰内心的捉急，还是为了掩饰特别宽的行距。

面试官似乎看出了什么，说道：用我的手提电脑吧，`IDE`、终端随便用，别给我百度就行。

表示感激之后，你立马将上一个优化版本的代码写到`IDE`里面，随后便是`echo`、`print_r`等到处飞。很快你就摸索出来了一些门路，发现有几次循环正在排序的数组内只有最前面的几个元素需要比较排序，后面大部分的元素已经是有序的了，但是结束比较排序的下标却将后面已经排好序的元素也囊括在内了。你会心一笑，暗道原来捷径就在这里。

```php
<?php

$arr = [6, 3, 54, 6, 23, 4, 26, 7, 18, 1, 4, 5, 67, 48, 9];
shuffle($arr);
$n = count($arr);
$lastChangePos = $n - 1;
for($j = 1; $j < $n; $j++){
        $changeFlag = false;
        for($i = 0; $i < $lastChangePos; $i++) {
                if($arr[$i] > $arr[$i+1]) {
                        $changeFlag = $i;
                        $arr[$i] += $arr[$i+1];
                        $arr[$i+1] = $arr[$i] - $arr[$i+1];
                        $arr[$i] = $arr[$i] - $arr[$i+1];
                }
        }
        $lastChangePos = $changeFlag;
        if(!$lastChangePos) {
                break;
        }
}
print_r($arr);
```

写完代码，感觉到行云流水一气呵成的快感，正准备给面试官讲解，突然你心里咯噔一下：咦！万一前面乱序的比后面有序的元素大，那不是漏掉了？

尽管心里一直在喊冷静，但你依然十分紧张，此时你发现面试官脸上出现了笑容：嗯，不错，这道题目就先这样吧，我们继续下面的问题……

面试完后，你简单的回想刚刚的问题，才发现是自己吓自己，即使前面乱序的部分有比后面有序的部分大的元素，但是上一次循环最后交换的位置肯定在乱序元素之后，因为冒泡排序就是先将乱序部分中最大（小）的元素先给顶置上去的，所以下一次循环的时候乱序中的大元素就会跟有序中的小元素进行比较排序了。

回家后的你觉得意犹未尽，小小的冒泡排序到底还能玩出什么花样？于是你又抓起了笔，当然，这些都是后话了……