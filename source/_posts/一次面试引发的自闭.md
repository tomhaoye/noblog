---
title: 一次面试引发的自闭
date: 2019-04-12 21:59:54
tags: algorithms
categories: 面试
---

>金三银四到了，我想各位互联网的童鞋们都有想到要去历练（mianshi）一番的想法。因为历练能给到你很多东西，例如能帮助你更加了解自身，能帮助你开拓视野，说不定还能帮你登上一个台阶。但是我却没想到，经历了一次面试之后，我自闭了。

事情是这样的，我投了某家独角兽公司，一面是视频面试，考核的知识点不多也不深，偏重解决方案与代码实战，整个过程感觉还是较为轻松的，拿到了二面的机会。

二面当天狂风暴雨，赶了几个小时路终于到了，下半身都基本湿透。等待了一阵子面试官就招呼我过去面试了，过程就不详细说了，反正我愣是一道题都没做对:joy:。两个小时的面试，基本在解决逻辑和算术问题，不能只说想法，需要公式和计算结果来体现。虽然我觉得我每道题目的思路都是没有太大问题的，但是最大的问题就是我在用公式表达和计算出来的答案跟我想的都不一样，当场怀疑人生，万念俱灰。不过还是很感谢面试官没有提早放弃我，只怪自己的能力有所欠缺。

故事概要就说到这里了，写这篇博客的目的还是对这次面试中没有好思路的一个算法题目进行解析。原题目如下：
```
给定一个数组，例如：[21, 11, 34, 42, 31, 66, 78, 70, 89, 121, 111]
找出数组中所有满足比前面所有元素都大并且比后面所有元素都小的元素的位置。
要求时间复杂度和空间复杂度都为 O(N) 。
```

如果不考虑时间复杂度，那么最符合人类思考方式的就是每个元素都分别跟它前面所有和后面所有的元素进行对比，这种应该就是最直观的解决方案，但是问题就在于，这种解决方案的说白了就是两层嵌套循环的遍历数组元素，那么这样一来时间复杂度就达到了 `O(N^2)` 的级别。

那要怎么才能做到题目要求的那样，时间复杂度和空间复杂度都为`O(N)`呢？面试官给了我如下提示：
```
遍历一次和遍历两次，时间复杂度都是O(N)。
多几个和这样长度一样的数组，空间复杂度也还是O(N)。
比前面所有都大，换句话来说是什么？
```

这……这我都知道啊，慢着，最后那句啥意思？到最后我都没有想明白最后那个提示是啥意思，是的，现在也没想明白。但是想不明白也要解决，既然想不明白面试官的提示，那就自己另辟蹊径呗。

这题目其实一开始我理解错了，因为原题里面是没有`所有`这个字眼的，跟面试官确认之后发现题意是如上所述那样，但是我想了一下，先确认每个元素是否跟前后两个元素满足上述条件，然后再对每次得到的结果集重复上述步骤直到结果集元素数量不再减少，也不妨是一种方案，再往深一想，这两种描述所得到的最后结果其实都是已经排好序的一个数组。但实际上这样的思路是有问题的，不过我们还是看一下代码，再进行分析：

```php
############## 错误示例 ###############
$array = [21, 11, 34, 42, 31, 66, 78, 70, 89, 121, 111];

function getResult(array $arr) {
    $lastCount = 0;
    while(count($arr) != $lastCount) {
        $lastKey = -1;
        $lastNum = -INF;
        $lastCount = count($arr);
        foreach ($arr as $key => $value) {
            if ($value <= $lastNum) {
                unset($arr[$key]);
                if ($lastKey > -1) {
                    unset($arr[$lastKey]);
                }
            }
            $lastKey = $key;
            $lastNum = $value;
        }
    }
    return $arr;
}

print_r(getResult($array));
```

大家可以看到我们这部分的代码是嵌套循环的，当外部循环发现元素数量不再改变的时候，就跳出循环，返回结果。那么这样的一个计算方法的时间复杂度和空间复杂度是在哪个级别呢，我们来慢慢分析一下。

首先，最好的情况，数组内所有的元素都满足题目要求，则外层循环只执行一次，里层遍历数组一次，所以最理想的情况的时间复杂度是`O(N)`。接下来我们想想一些极端情况，例如除了最后一个元素，前面所有的元素都是排好序的，但是偏偏最后一个元素就是最小的，这种情况下，最后一个元素会先被消除掉，所以后面再比较就都符合题意了，所以这种解法实际上是有问题的，我们给代码标注上`错误示例`的标识。

既然上面的方案有问题，那我们还需要重新整理思路。我们刚刚想要的是最后的结果是一个符合题目要求的元素的排好序的数组，那么原来的数组我们可以看作是乱序的数组（不排除有序的可能），而符合题目要求的元素在原数组里面是处于什么位置呢？其实我们可以尝试将原数组进行排序，大家会发现符合题意的元素位置跟排序前是没有变化的，因为前面比它小的元素排序不会排到它后面去，后面比它大的元素也同理。

于是我们的解决方案就可以是：对原数组进行排序，然后再对比排序前和后的数组，两数组同下标情况下元素数值一样的，就是符合题意的元素了。那么开始写代码：

```php
########### 时间复杂度和空间复杂度在某些情况下能满足题目要求 ###########
$array = [21, 11, 34, 42, 31, 66, 78, 70, 89, 121, 111];

function getResult(array $arr) {
    $map = [];
    $sortedArr = $arr;
    sort($sortedArr);
    $result = [];
    for ($i=0; $i < count($arr); $i++) { 
        $map[$arr[$i]] = isset($map[$arr[$i]])?$map[$arr[$i]]+1:1;
        if ($arr[$i] == $sortedArr[$i]) {
            $result[] = $arr[$i];
        }
    }
    foreach ($result as $key => $value) {
        if ($map[$value] > 1){
            unset($result[$key]);
        }
    }
    return $result;
}

print_r(getResult($array));
```

同样的我们先计算一下时间复杂度，这个方案的耗时主要是排序和遍历部分（后面加入的排除相同数的部分代码对两种复杂度都没影响）。遍历部分只遍历一次，看作`O(N)`，那么排序的耗时，主要还是看排序算法，较为通用的排序算法时间复杂度一般都是`O(NlogN)`到`O(N^2)`之间，好像不满足。那么我们就暂时假定可以使用限制性较大的排序，如计数排序，那么这个方案的时间复杂度就是`O(N)`了。

接下来再看看空间复杂度。方案内使用的额外空间包括排序算法所需要的额外空间，以及我们复制出来的待排序数组和定义的`$result`。上面假定可以使用计数排序，空间复杂度跟最大值有关，那么这样看来空间复杂度有点不可控。

这个方案理论上没有太大问题，如果说有相同的数那么加多一个`Map`进行排除掉就行了。但是数组元素的取值必须在限制性较大的范围内才能满足题目对时间复杂度和空间复杂度都的要求。那么还有没有更加好的思路呢？

有是必须有的，实际上更好的解决思路就是面试官给予的提示，到现在我才恍然大悟，他所给的三个提示，可以说的就是这道题目的简化版的答案。这个思路最早在前面两个方案想出来之前已经走过一遍了，但是脑子转不过弯，只解决了一半，往下好像还缺点什么，就当作是错误的思路抛弃了。

一开始我想的是：初始化最大值为负无穷，遍历数组，将当前元素与最大值比对，得出最大值并替换，将最大值的放到`数组2`中，直到遍历完成。然后原数组与`数组2`比对，对应下标的元素如果值相等，那就是满足比前面所有元素都大的这个条件了。但是接下来的问题是那怎么满足比后面都小这个条件呢？虽然很不想承认，但是我真的是名副其实的猪脑子:joy:。那时候我想的是：

~~那不是又要访问当前元素的后面一个元素是不是跟当前元素一样，如果一样就是不满足，那再后面一个元素如果又替换了我怎么知道原来的值？~~

大家不要被我带偏了，现在想来是真的蠢，都已经会从前面遍历将大值覆盖小值了，怎么就不会从后面再遍历一次将小值去覆盖大值呢？所以解决方案真的就是那么简单：

```php
##############更好的解法，这里用map去除重复值就略了，参照上面的就行##############
$array = [21, 11, 34, 42, 31, 66, 78, 70, 89, 121, 111];

function getResult(array $arr) {
    $max = -INF;
    $arr2 = [];
    $min = INF;
    $arr3 = [];
    $result = [];
    for ($i=0; $i < count($arr); $i++) { 
        $max = $max > $arr[$i] ? $max : $arr[$i];
        $arr2[] = $max;
    }
    for ($j=count($arr)-1; $j >= 0; $j--) { 
        $min = $min < $arr[$j] ? $min : $arr[$j];
        $arr3[$j] = $min;
    }
    foreach ($arr as $key => $value) {
        // 不知道为啥它把我代码里面的 && 转义了-_-#，那我就分开写吧。这注释你就不转义-_-#，存心逗我吧
        if ($value == $arr2[$key]){
            if ($value == $arr3[$key]) {
                $result[] = $value;
            }
        }
    }
    return $result;
}

print_r(getResult($array));
```
虽然说面试现场紧张也是在所难免，但是马后炮就更加没意思了。失败不是偶然，都是自身能力不足导致的，所以最重要的还是从失败中吸取教训，面试中的每一个问题，即使当场提供了解决方案的，都可以再深入研究。至于紧张情绪方面的，也不是说面多几次就能适应，还是需要对自己有充足的信心，也需要明白面试官不是你的敌人，他们都想早日找到合适的人，所以他们也是会帮助你的。

最后，其实上面都是我自己写给自己看的:smile:，相信各位童鞋都早已解决了上述的问题，相信也有很多的童鞋已经拿到了心仪的`offer`了。但是不管捷报与否，生命不止，奋斗不息。

完。